import primes, os


class VigLocksmith:
    """"Geneterates a sequence of numbers from diffe-hellman to come up with a Vigenere Cipher Key

    65 is added to keys to give letters

    """

    def __init__(self, g, n, initialValue):
        """
        Initializes the Vigenere Locksmith. 

        Args:
            g(int): A primitive root of n 
            n(int): A prime number
            initialValue(int): List of secret nums. Length of randomNums must be same for both parties

        """
        if not primes.isPrimitiveRoot(g, n):
            raise ValueError(str(g) + "is not a primitive root of " + str(n))
        self.g = g
        self.n = n
        self.initialValue = initialValue
        self.intermValCalced = False
        self.keyCalced = False
        self.IntermediateVal = self.makeIntermediateVal()

    def makeIntermediateVal(self):
        """Makes the intermediate value/public key to send to other party

        To discourage session key re-use, may only be called once.

        Returns:
          The intermediate value to be given to other party
        """
        if self.intermValCalced:
            raise ValueError("Intermediate Value should only be calculated once.")
        self.intermValCalced = True
        return VigLocksmith.numsToKey([pow(self.g, randNum, self.n) for randNum in VigLocksmith.keyToNums(self.initialValue, 64)],64)

    def updateIntermediateVal(self, otherContribution):
        try:
            asNums = [pow(pair[1], pair[0], self.n) for pair in
                  zip(VigLocksmith.keyToNums(self.initialValue, 64), VigLocksmith.keyToNums(otherContribution, 64))]
        except TypeError:
            asNums = [pow(pair[1], pair[0], self.n) for pair in
                      zip(VigLocksmith.keyToNums(self.initialValue, 64), otherContribution)]
        return asNums

    def makeKey(self, otherContribution):
        """Creates a session key using secret list and contribution list from other party.

        To discourage session key re-use, may only be called once.

        Args:
          otherContribution(string): The result of other party's intermediate value 

        Returns:
          The session key as a string.
        """

        def convert(i):
            """Adds 65 to integer i and returns the resulting character"""
            return chr(65 + i)

        if self.keyCalced:
            raise ValueError("Key should only be calculated once.")
        self.keyCalced = True
        asNums = [pow(pair[1], pair[0], self.n) for pair in zip(VigLocksmith.keyToNums(self.initialValue, 64), otherContribution)]
        return "".join(map(convert, asNums))

    @staticmethod
    def keyToNums(string, offset):
        converter = lambda c: ord(c) - offset
        return list(map(converter, string))

    @staticmethod
    def numsToKey(nums, offset):
        print("RECEIVED " + str(nums))
        converter = lambda i: chr(i + offset)
        return "".join(list(map(converter, nums)))


def genVigKey(length):
    """Generates a random key of upper and lowercase letters of the specified length"""
    # os.urnandom is generated by OS and supposed to be more random
    # 4.48 comes from 255/57 rounded up slightly for safety
    # 65 is where A starts, there is a bit of punctuation in betwen
    # 122 is z 122 - 65 = 57
    return "".join([chr(int(ord(os.urandom(1)) / 4.48) + 65) for i in range(0, length)])


def multi_parties(parties, g = None):
    """
    :param parties: a list of Locksmith objects
    :param g: public key
    :return: new public-private key
    """

    if len(parties) <= 1:
        print(parties[0].makeKey(g))
        return

    # Divide and conquer
    middle = len(parties) // 2
    left = parties[:middle]
    right = parties[middle:]

    if g == None:
        g_r = left[0].IntermediateVal[:]
        for i in range(1, len(left)):
            g_r = left[i].updateIntermediateVal(g_r)[:]

        g_l = right[0].IntermediateVal[:]
        for i in range(1, len(right)):
            g_l = right[i].updateIntermediateVal(g_l)[:]

    else:
        g_r = g[:]
        g_l = g[:]
        for m in left:
            g_r = m.updateIntermediateVal(g_r)[:]
        for m in right:
            g_l = m.updateIntermediateVal(g_l)[:]

    multi_parties(left, g_l)
    multi_parties(right, g_r)


parties = []
n = 997
g = 7
for i in range(3):
    parties.append(VigLocksmith(g, n, genVigKey(5)))

multi_parties(parties)

